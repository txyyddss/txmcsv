name: Create Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'ç‰ˆæœ¬å·'
        required: true
        type: string

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: æ›¿æ¢ç‰ˆæœ¬å·
        run: |
          sed -i "s/%server_version%/${{ github.event.inputs.version }}/g" ./plugins/AnimatedScoreboard/scoreboards/globalscoreboard.yml
          sed -i "s/%server_version%/${{ github.event.inputs.version }}/g" ./plugins/AnimatedScoreboard/scoreboards/globalnoseason.yml

      - name: æ¸…ç†æ’ä»¶ç›®å½•
        run: |
          find ./plugins -type f -not \( -name "*.yml" -o -name "*.conf" -o -name "*.txt" -o -name "*.jar" \) -delete

      - name: è¯»å– manual.txt
        id: manual
        run: |
          if [ -f "manual.txt" ]; then
            MANUAL_CONTENT=$(cat manual.txt)
            echo "content<<EOF" >> $GITHUB_OUTPUT
            echo "$MANUAL_CONTENT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "content=" >> $GITHUB_OUTPUT
          fi

      - name: æ‰“åŒ…æ›´æ–°æ–‡ä»¶
        run: |
          find . -type f -not \( -path "./.git*" -o -path "./.github*" -o -name ".gitattributes" -o -name "README.md" -o -name "manual.txt" \) | zip -@ update_pack.zip

      - name: è·å– Issues å¹¶ç”Ÿæˆ Changelog
        id: changelog
        uses: actions/github-script@v6
        with:
          script: |
            const { owner, repo } = context.repo;
            
            // è·å–æœ€æ–°çš„ release
            let latestRelease;
            try {
              latestRelease = await github.rest.repos.getLatestRelease({
                owner,
                repo
              });
            } catch (error) {
              console.log('No previous release found');
            }
            
            // è·å–æ—¶é—´èŒƒå›´
            const since = latestRelease ? latestRelease.data.created_at : null;
            
            // è·å–æ‰€æœ‰å·²å…³é—­çš„ issues
            const issuesResponse = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'closed',
              per_page: 100
            });
            
            // è¿‡æ»¤å‡º completed çŠ¶æ€ï¼Œé wontfix/invalid çš„ issues
            const completedIssues = issuesResponse.data.filter(issue => {
              // æ’é™¤ pull requests
              if (issue.pull_request) return false;
              
              // åªå¤„ç† close æ—¶é—´åœ¨æœ€æ–° release ä¹‹åçš„ issues
              if (since && new Date(issue.closed_at) <= new Date(since)) return false;
              
              // æ’é™¤æ ‡è®°ä¸º wontfix æˆ– invalid çš„ issues
              const labels = issue.labels.map(label => label.name.toLowerCase());
              if (labels.includes('wontfix') || labels.includes('invalid')) return false;
              
              return true;
            });
            
            // åˆ†ç±» issues
            const bugFixes = [];
            const features = [];
            
            completedIssues.forEach(issue => {
              const title = issue.title
                .replace(/\[Bug\]:\s*/i, '')
                .replace(/\[Feature request\]:\s*/i, '');
              
              if (issue.title.toLowerCase().includes('[bug]')) {
                bugFixes.push({ title, number: issue.number });
              } else if (issue.title.toLowerCase().includes('[feature request]')) {
                features.push({ title, number: issue.number });
              }
            });
            
            // ç”Ÿæˆ Changelog
            let changelog = '# ğŸ“¦ æ›´æ–°å†…å®¹ï¼š\n\n';
            
            // æ·»åŠ æ‰‹åŠ¨æ›´æ”¹éƒ¨åˆ†
            const manualContent = process.env.MANUAL_CONTENT || '';
            if (manualContent.trim()) {
              changelog += '## æ‰‹åŠ¨æ›´æ”¹\n' + manualContent + '\n\n';
            } else {
              changelog += '## æ‰‹åŠ¨æ›´æ”¹\n\n';
            }
            
            // æ·»åŠ  Bug ä¿®å¤éƒ¨åˆ†
            changelog += '## Bugä¿®å¤\n';
            if (bugFixes.length > 0) {
              bugFixes.forEach(bug => {
                changelog += `ä¿®å¤äº†${bug.title}çš„é—®é¢˜ #${bug.number}\n`;
              });
            }
            changelog += '\n';
            
            // æ·»åŠ åŠŸèƒ½æ›´æ”¹éƒ¨åˆ†
            changelog += '## åŠŸèƒ½æ›´æ”¹\n';
            if (features.length > 0) {
              features.forEach(feature => {
                changelog += `${feature.title} #${feature.number}\n`;
              });
            }
            
            // è¾“å‡º changelog
            return changelog;
        env:
          MANUAL_CONTENT: ${{ steps.manual.outputs.content }}

      - name: åˆ›å»ºå‘å¸ƒç‰ˆæœ¬
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ format('{0}_{1}', github.event.inputs.version, format('{0}.{1}.{2}', format('{0:04}', steps.date.outputs.year), format('{0:02}', steps.date.outputs.month), format('{0:02}', steps.date.outputs.day))) }}
          name: ${{ format('{0}.{1}.{2}_{3}', format('{0:04}', steps.date.outputs.year), format('{0:02}', steps.date.outputs.month), format('{0:02}', steps.date.outputs.day), github.event.inputs.version) }}
          body: ${{ steps.changelog.outputs.result }}
          files: update_pack.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: è·å–å½“å‰æ—¥æœŸ
        id: date
        run: |
          echo "year=$(date +'%Y')" >> $GITHUB_OUTPUT
          echo "month=$(date +'%m')" >> $GITHUB_OUTPUT
          echo "day=$(date +'%d')" >> $GITHUB_OUTPUT
