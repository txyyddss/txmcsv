
name: Create Release

on:
  workflow_dispatch:  # æ‰‹åŠ¨è§¦å‘
    inputs:
      version:
        description: 'ç‰ˆæœ¬å·'
        required: true
        default: '1.0.0'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # èŽ·å–å®Œæ•´åŽ†å²ä»¥ä¾¿èŽ·å–æ‰€æœ‰issues
      
      - name: Replace version in files
        run: |
          if [ -f "./plugins/AnimatedScoreboard/scoreboards/globalscoreboard.yml" ]; then
            sed -i "s/%server_version%/${{ github.event.inputs.version }}/g" ./plugins/AnimatedScoreboard/scoreboards/globalscoreboard.yml
            echo "å·²æ›¿æ¢ globalscoreboard.yml ä¸­çš„ç‰ˆæœ¬å·ä¸º ${{ github.event.inputs.version }}"
          else
            echo "globalscoreboard.yml æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡æ›¿æ¢"
          fi
          
          if [ -f "./plugins/AnimatedScoreboard/scoreboards/globalnoseason.yml" ]; then
            sed -i "s/%server_version%/${{ github.event.inputs.version }}/g" ./plugins/AnimatedScoreboard/scoreboards/globalnoseason.yml
            echo "å·²æ›¿æ¢ globalnoseason.yml ä¸­çš„ç‰ˆæœ¬å·ä¸º ${{ github.event.inputs.version }}"
          else
            echo "globalnoseason.yml æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡æ›¿æ¢"
          fi
      
      - name: Clean plugins directory
        run: |
          if [ -d "./plugins" ]; then
            # æ‰¾å‡ºæ‰€æœ‰ä¸ç¬¦åˆä¿ç•™æ¡ä»¶çš„æ–‡ä»¶å¹¶åˆ é™¤å®ƒä»¬ï¼Œä½†ä¿ç•™ç›®å½•ç»“æž„
            find ./plugins -type f -not \( -name "*.yml" -o -name "*.conf" -o -name "*.txt" -o -name "*.jar" \) -delete
            echo "Plugins ç›®å½•æ¸…ç†å®Œæˆï¼Œå·²ä¿ç•™æ‰€æœ‰æ–‡ä»¶å¤¹ç»“æž„å’ŒæŒ‡å®šç±»åž‹çš„æ–‡ä»¶"
          else
            echo "Plugins ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡æ¸…ç†"
          fi
      
      - name: Create update_pack.zip
        run: |
          zip -r update_pack.zip . -x "README.md" ".github/*" ".git/*" ".gitattributes" "manual.txt"
          echo "å·²åˆ›å»º update_pack.zip æ–‡ä»¶"
      
      - name: Generate changelog and release tag
        id: changelog
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const today = new Date();
            const formattedDate = `${today.getFullYear()}.${String(today.getMonth() + 1).padStart(2, '0')}.${String(today.getDate()).padStart(2, '0')}`;
            const releaseTag = `${formattedDate}_${process.env.VERSION}`;
            core.exportVariable('RELEASE_TAG', releaseTag);
            
            console.log(`Release tag will be: ${releaseTag}`);
            
            // èŽ·å–æœ€æ–°releaseçš„æ—¥æœŸ
            let lastReleaseDate = null;
            try {
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 1
              });
              
              if (releases.length > 0) {
                lastReleaseDate = new Date(releases[0].published_at);
                console.log(`Last release date: ${lastReleaseDate.toISOString()}`);
              }
            } catch (error) {
              console.log("No previous releases found or error occurred:", error);
            }
            
            // èŽ·å–æ‰€æœ‰å·²å…³é—­çš„issues
            const allIssues = [];
            let page = 1;
            let hasMoreIssues = true;
            
            while (hasMoreIssues) {
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed',
                per_page: 100,
                page: page
              });
              
              if (issues.length === 0) {
                hasMoreIssues = false;
              } else {
                // è¿‡æ»¤issuesï¼š
                // 1. ä¸æ˜¯PR
                // 2. çŠ¶æ€ä¸ºcompletedï¼ˆå·²å®Œæˆï¼‰
                // 3. æ²¡æœ‰wontfixæˆ–invalidæ ‡ç­¾
                // 4. å¦‚æžœæœ‰lastReleaseDateï¼Œåˆ™åªèŽ·å–åœ¨è¯¥æ—¥æœŸä¹‹åŽå…³é—­çš„issues
                const filteredIssues = issues.filter(issue => {
                  if (issue.pull_request) return false;
                  if (issue.labels.some(label => 
                    label.name.toLowerCase() === 'wontfix' || 
                    label.name.toLowerCase() === 'invalid'
                  )) return false;
                  if (lastReleaseDate && new Date(issue.closed_at) <= lastReleaseDate) return false;
                  return true;
                });
                
                allIssues.push(...filteredIssues);
                page++;
                
                // å¦‚æžœèŽ·å–çš„issuesæ•°é‡å°äºŽæ¯é¡µæ•°é‡ï¼Œè¯´æ˜Žæ²¡æœ‰æ›´å¤šissuesäº†
                if (issues.length < 100) {
                  hasMoreIssues = false;
                }
              }
            }
            
            console.log(`Found ${allIssues.length} relevant issues`);
            
            // åˆ†ç±»issues
            const bugs = [];
            const features = [];
            
            for (const issue of allIssues) {
              // å¤„ç†æ ‡é¢˜ï¼ŒåŽ»é™¤å‰ç¼€
              let title = issue.title;
              title = title.replace(/^\[Bug\]:\s*/i, "").replace(/^\[Feature request\]:\s*/i, "").trim();
              
              // æ£€æŸ¥issueæ˜¯å¦ä¸ºbug
              const isBug = issue.labels.some(label => 
                label.name.toLowerCase().includes('bug') || 
                label.name.toLowerCase().includes('ä¿®å¤') || 
                label.name.toLowerCase().includes('fix')
              ) || issue.title.toLowerCase().includes('[bug]');
              
              if (isBug) {
                bugs.push({...issue, cleanTitle: title});
              } else {
                features.push({...issue, cleanTitle: title});
              }
            }
            
            console.log(`Bugs: ${bugs.length}, Features: ${features.length}`);
            
            // ç”Ÿæˆchangelog
            let changelog = "# ðŸ“¦ æ›´æ–°å†…å®¹ï¼š\n";
            
            // è¯»å–manual.txtæ–‡ä»¶å†…å®¹
            let manualContent = '';
            try {
              if (fs.existsSync('manual.txt')) {
                manualContent = fs.readFileSync('manual.txt', 'utf8');
                changelog += "\n## æ‰‹åŠ¨æ›´æ”¹\n" + manualContent + "\n";
              } else {
                console.log("manual.txt file not found");
                changelog += "\n## æ‰‹åŠ¨æ›´æ”¹\n\n";
              }
            } catch (error) {
              console.log("Error reading manual.txt:", error);
              changelog += "\n## æ‰‹åŠ¨æ›´æ”¹\n\n";
            }
            
            changelog += "\n## Bugä¿®å¤\n";
            if (bugs.length > 0) {
              for (const bug of bugs) {
                changelog += `ä¿®å¤äº†${bug.cleanTitle}çš„é—®é¢˜ #${bug.number}\n`;
              }
            }
            
            changelog += "\n## åŠŸèƒ½æ›´æ”¹\n";
            if (features.length > 0) {
              for (const feature of features) {
                changelog += `${feature.cleanTitle} #${feature.number}\n`;
              }
            }
            
            // è¾“å‡ºchangelog
            core.setOutput('changelog', changelog);
            fs.writeFileSync('CHANGELOG.md', changelog);
          env:
            VERSION: ${{ github.event.inputs.version }}
      
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_TAG }}
          body_path: CHANGELOG.md
          draft: false
          prerelease: false
          files: |
            update_pack.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
